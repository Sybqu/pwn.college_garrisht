# Named pipes
You'll need to create a /tmp/flag_fifo file and redirect the stdout of /challenge/run to it. If you're successful, /challenge/run will write the flag into the FIFO! Go do it!
**Flag:**pwn.college{wGM4DO1x8uJYFksZlZn2RUTnBLO.01MzMDOxwCOzAzNzEzW}



```bash
khacker@piping~named-pipes:~$ kfifo /tmp/flag_fifo
bash: kfifo: command not found
hacker@piping~named-pipes:~$ mkfifo /tmp/flag_fifo
hacker@piping~named-pipes:~$ /challenge/run > /tmp/flag_fifo | cat /tmp/flag_fifo
You're successfully redirecting /challenge/run to a FIFO at /tmp/flag_fifo! 
Bash will now try to open the FIFO for writing, to pass it as the stdout of 
/challenge/run. Recall that operations on FIFOs will *block* until both the 
read side and the write side is open, so /challenge/run will not actually be 
launched until you start reading from the FIFO!
You've correctly redirected /challenge/run's stdout to a FIFO at 
/tmp/flag_fifo! Here is your flag:
pwn.college{wGM4DO1x8uJYFksZlZn2RUTnBLO.01MzMDOxwCOzAzNzEzW}
hacker@piping~named-pipes:~$ 

```
ah i was not getting a new console. So uh i piped and do it all in one single line.
## What I learned
mkfifo command used to make fifo files which stick around unless removed manually (first byte In first byte Out(fifo))
u need to read and write into fifo to complete the pipe . if only one process is done the pipe remains "blocked" till then.
p- at the beginning of files is used to represent "pipe" hence fifo files
They have a couple of advantages
1. No disk storage
2. Ephemeral data
3. Automatic synchronization
4. Complex data flows
## References 
.